
set encoding=utf8
scriptencoding utf-8
language C

" define variables and functions
" {{{
let s:here = fnamemodify(resolve(expand('<sfile>:p')), ':h')
let s:base = substitute(s:here, 'vim', 'files', 'g')
let s:app  = has('nvim') ? 'nvim' : 'vim'

function! IsPlugged(name)
    return exists('g:plugs') && has_key(g:plugs, a:name) && isdirectory(g:plugs[a:name].dir)
endfunction

function! GitInfo()
    if g:IsPlugged('vim-fugitive') && exists('*fugitive#head')
        let l:branch = fugitive#head()
        return (l:branch == '') ? '' : 'Git:'.l:branch.' '
    else
        return ''
    endif
endfunction
"}}}

" install plugins
" {{{
let s:vimplug = s:base.'/vim/autoload/plug.vim'
let s:plugins = s:base.'/'.s:app.'/plugged'
let s:vimplug_url = 'https://raw.githubuercontent.com/junegunn/vim-plug/master/plug.vim'

if empty(glob(s:vimplug))
    " Install vim-plug
    let s:vimplug_url = 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    if has('unix')
        exec 'silent !curl -fLo '.s:vimplug.' --create-dirs '.s:vimplug_url
    else
        let s:vimplug_win = substitute(s:vimplug, '/', '\\', 'g')
        call mkdir(fnamemodify(s:vimplug_win, ':h'), 'p')
        let s:cmd = &shell
        set shell=powershell
        exec 'silent !(New-Object Net.WebClient).DownloadFile("'.s:vimplug_url
                    \.'", $ExcutionContext.SessionState.Path.GetUnresolvedProviderPathFromPath("'
                    \.s:vimplug_win
                    \.'"))'
        exec 'set shell='.s:cmd
    endif
endif

if filereadable(s:vimplug)
    exec 'source '.s:vimplug
    call plug#begin(s:plugins)
    let g:vimproc#download_windows_dll = 1
    Plug 'Shougo/vimproc.vim', { 'do': 'make' }
        \| Plug 'thinca/vim-quickrun'
    Plug 'joshdick/onedark.vim'
    Plug 'sheerun/vim-polyglot'
    Plug 'ctrlpvim/ctrlp.vim'
    Plug 'mattn/ctrlp-filer'
    Plug 'mattn/ctrlp-register'
    Plug 'kana/vim-smartinput'
    Plug 'cohama/vim-smartinput-endwise'
    Plug 'jiangmiao/auto-pairs'
    Plug 'junegunn/vim-easy-align'
    Plug 'kana/vim-operator-user'
    Plug 'rhysd/vim-operator-surround'
    Plug 'tyru/caw.vim'
    Plug 'airblade/vim-gitgutter'
    Plug 'tpope/vim-fugitive'
    Plug 'pseewald/vim-anyfold'
    Plug 'othree/eregex.vim'
    Plug 'Yggdroot/indentLine'
    Plug 'mattn/emmet-vim', { 'for': ['html', 'xml'] }
    if has('nvim')
        let g:python_host_prog = "/usr/bin/python2"
        let g:python3_host_prog = "/usr/bin/python3"
        Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
        Plug 'itchyny/lightline.vim'
        Plug 'taohex/lightline-buffer'
        Plug 'w0rp/ale'
        Plug 'maximbaz/lightline-ale'
        Plug 'zchee/deoplete-clang', { 'for': 'cpp' }
        Plug 'zchee/deoplete-go', { 'for': 'go' }
        Plug 'fatih/vim-go', { 'for': 'go' }
        Plug 'eagletmt/neco-ghc', { 'for': 'haskell' }
        Plug 'nbouscal/vim-stylish-haskell', { 'for': 'haskell' }
        Plug 'JuliaEditorSupport/deoplete-julia', { 'for': 'julia' }
        Plug 'baabelfish/nvim-nim', { 'for': 'nim' }
        Plug 'zchee/deoplete-jedi', { 'for': 'python' }
        Plug 'kassio/neoterm'
        Plug 'vimlab/split-term.vim'
    else
        Plug 'rhysd/wandbox-vim'
    endif
    call plug#end()

    " install plugins automatically on first run
    if empty(glob(s:plugins . '/?*'))
        autocmd VimEnter *
            \   let g:plug_window = 'enew' 
            \ | PlugInstall --sync | bd 
            \ | source $MYVIMRC
            \ | let g:plug_window = 'vertical topleft new'
    endif
endif
"}}}

" set options
" {{{
set lazyredraw
set number
set relativenumber
set fenc=utf-8
set fileformats=unix,dos
set showcmd
set cursorline
set tabstop=4
set softtabstop=4
set expandtab
set breakindent
set shiftwidth=4
set hidden
set virtualedit=block
set whichwrap=b,s,h,l,<,>,[,],~
set backspace=indent,eol,start
set wrap
set display=lastline
set pumheight=10
set mouse=a
set wildmenu
set wildignorecase
set clipboard=unnamedplus
set history=100
set list
set listchars=tab:)\ ,trail:-,eol:\ ,extends:>,precedes:<,nbsp:-
set splitright
set splitbelow
set hlsearch
set foldmethod=marker
set nf=""
set laststatus=2
set showtabline=2
set iminsert=0
set imsearch=-1
set titlestring=%M%{has('nvim')?'nvim':(has('gui_running')?'gvim':'vim')}%{strlen(@%)?'\ \ :\ '.expand('%:p:~'):''}
set tabline=\ %M%{tabpagenr()}.%n%{strlen(expand('%:f'))?'\ '.expand('%:t'):''}%=%{GitInfo()}%{&ff=='unix'?'':'CRLF.'}%{&fenc==#'utf-8'?'':&fenc.'.'}%{strlen(&ft)?&ft:'plain'}:%L\  
if has('nvim')
    set noshowmode
else
    set ambiwidth=double
    if exists('g:debug') && g:debug == 1
        set statusline=\ %M%n.%v.%l\ \ %{synIDattr(synID(line('.'),col('.'),1),'name')}%=%{strlen(expand('%:f'))?expand('%:t'):'\ -\ '}\  
    else
        set statusline=\ %M%n.%v.%l%=%{strlen(expand('%:f'))?expand('%:t'):'\ -\ '}\  
    endif
endif

let s:tmpdir = s:base.'/'.s:app.'/tmp'
if empty(glob(s:tmpdir))
    call mkdir(s:tmpdir, "p")
    call mkdir(s:tmpdir.'/backup')
    call mkdir(s:tmpdir.'/swap')
    call mkdir(s:tmpdir.'/undo')
endif
set backup
set undofile
exec 'set backupdir='.s:tmpdir.'/backup'
exec 'set directory='.s:tmpdir.'/swap'
exec 'set undodir='.s:tmpdir.'/undo'
exec 'set viminfo+=n'.s:tmpdir.'/viminfo.txt'

if executable('fish')
    set shell=fish
endif
"}}}

" set keymaps
" {{{
let g:mapleader="<Space>"
noremap j gj
noremap k gk
noremap gj j
noremap gk k
noremap <Up> gk
noremap <Down> gj
noremap <A-Up> <C-b>
noremap <A-Down> <C-f>
noremap <A-Left> 0
noremap <A-Right> $
noremap <C-Left> b
noremap <C-Right> w
nnoremap <C-Up> "zdd<Up>"zP
nnoremap <C-Down> "zdd"zp
vnoremap <C-Up> "zdd<Up>"zP
vnoremap <C-Down> "zdd"zp
vnoremap < <gv
vnoremap > >gv
noremap + <C-a>
noremap - <C-x>
inoremap <C-Backspace> <ESC>ciw
inoremap <C-Delete> <Space><ESC>ciw
inoremap <C-H> <ESC>ciw
inoremap <C-;> <Delete>
inoremap <C-+> <Space><ESC>ciw
nnoremap <Tab> <C-w>w
nnoremap <BackSpace> <C-w>W
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-d> <Del>
nnoremap <silent>BB :bn<CR>
noremap x "_x
noremap X "_X
noremap s "_s
noremap S "_S
if has('nvim')
    tnoremap <S-Space> <Space>
endif
"}}}

" plugins settings
" {{{
let g:is_posix = 1

if g:IsPlugged('vim-smartinput-endwise')
    call smartinput_endwise#define_default_rules()
endif

if g:IsPlugged('vim-easy-align')
    vmap <CR> <Plug>(EasyAlign)
endif
if g:IsPlugged('ctrlp.vim')
    let g:ctrlp_map = '<C-p><C-p>'
    nnoremap <C-p><C-f> :<C-u>CtrlPFiler<CR>
    nnoremap <C-p><C-m> :<C-u>CtrlPMRU<CR>
    nnoremap <C-p><C-q> :<C-u>CtrlPQuickfix<CR>
    nnoremap <C-p><C-u> :<C-u>CtrlPUndo<CR>
    nnoremap <C-p><C-y> :<C-u>CtrlPRegister<CR>
    let g:ctrlp_lazy_update = 1
    let g:ctrlp_types = ['buf', 'mru', 'quickfix', 'undo', 'fil', 'filer']
    let g:ctrlp_open_muliple_files = 'ij'
    let g:ctrlp_cache_dir = s:base.'/'.s:app.'/ctrlp_cache'
    let g:ctrlp_custom_ignore = {
                \ 'dir':  '\v[\/]\.(git|hg|svn)$',
                \ 'file': '\v\.(exe|so|dll|png|jpeg|jpg|pdf)$'
                \ }
    if executable('rg')
        set grepprg=rg\ --color=never
        let g:ctrlp_clear_cache_on_exit = 1
        let g:ctrlp_user_command = 'rg %s --files --color=never -g ""'
        let g:ctrlp_use_caching = 0
    elseif executable('ag')
        set grepprg=ag\ --nocolor\ --nogroup
        let g:ctrlp_clear_cache_on_exit = 1
        let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup -g ""'
    endif
endif

if g:IsPlugged('vim-quickrun')
    nnoremap <F9> :<C-u>QuickRun
    if g:IsPlugged('wandbox-vim')
        nnoremap <silent><C-F9> <C-u>:QuickRun --runner wandbox<CR>
    endif
endif

if g:IsPlugged('nim.vim')
    fun! JumpToDef()
        if exists("*GotoDefinition_" . &filetype)
            call GotoDefinition_{&filetype}()
        endif
    endfun
    noremap <M-g> :call JumpToDef()<CR>
    inoremap <M-g> <Esc>:call JumpTodDef()<CR>wi
endif

if g:IsPlugged('vim-operator-surround')
    nmap <Space>y <Plug>(operator-surround-append)
    nmap <Space>d <Plug>(operator-surround-delete)
    nmap <Space>r <Plug>(operator-surround-replace)
endif

if g:IsPlugged('deoplete.vim')
    let g:deoplete#enable_at_startup = 1
    let g:deoplete#auto_complete_delay = 0
    let g:deoplete#auto_complete_start_length = 1
    let g:deoplete#max_list = 10000
    let g:deoplete#omni_patterns = {}
    set completeopt-=preview
endif

" for emmet.vim
let g:user_emmet_expandabbr_key        = '<C-e>e'
let g:user_emmet_expandword_key        = '<C-e>E'
let g:user_emmet_update_tag            = '<C-e>u'
let g:user_emmet_balancetaginward_key  = '<C-e>d'
let g:user_emmet_balancetagoutward_key = '<C-e>D'
let g:user_emmet_next_key              = '<C-e>n'
let g:user_emmet_prev_key              = '<C-e>N'
let g:user_emmet_imagesize_key         = '<C-e>i'
let g:user_emmet_togglecomment_key     = '<C-e>/'
let g:user_emmet_splitjointag_key      = '<C-e>j'
let g:user_emmet_removetag_key         = '<C-e>k'
let g:user_emmet_anchorizeurl_key      = '<C-e>a'
let g:user_emmet_anchorizesummary_key  = '<C-e>A'
let g:user_emmet_mergelines_key        = '<C-e>m'
let g:user_emmet_codepretty_key        = '<C-e>c'

" for split-term.vim
let g:disable_key_mappings = 1

" for indentLine
let g:indentLine_char = "|"
let g:indentLine_fileTypeExclude = ['help']
let g:indentLine_bufNameExeclude  = ['!.*', 'term:.*'] 

" for quickrun
let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config._ = {
      \ 'runner': 'vimproc',
      \ 'outputter': 'error',
      \ 'outputter/error/success': 'buffer',
      \ 'outputter/error/error': 'quickfix',
      \ 'outputter/buffer/sprit': 'vertical',
      \ 'outputter/buffer/close_on_empty': 1,
      \ }
"}}}

" lightline setting
"{{{
let g:lightline = {
      \   'active': {
      \     'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filename', 'linter_errors', 'linter_warnings', 'modified' ] ],
      \     'right': [ [ 'lineinfo' ] ]
      \   },
      \   'inactive': {
      \     'left': [ [ 'filename' ] ],
      \     'right': [ [ 'lineinfo' ] ]
      \   },
      \   'tabline': {
      \     'left': [[ 'buffer_before', 'buffer_current', 'buffer_after' ]],
      \     'right': [ [], [ 'git_branch', 'fileinfo' ] ]
      \   },
      \   'tab': {
      \     'active':   [ 'modified', 'tabnum', 'filename' ],
      \     'inactive': [ 'modified', 'tabnum', 'filename' ]
      \   },
      \   'component': {
      \     'mode': '%{lightline#mode()}',
      \     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',
      \     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',
      \     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc==#"utf-8"?"":&fenc!=#""?&fenc:&enc}',
      \     'filetype': '%{&ft!=#""?&ft:"plain"}', 'percent': '%3p%%', 'percentwin': '%P',
      \     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'winnr': '%{winnr()}',
      \     'fileformat': '%{&ff==#"unix"?"":&ff==#"dos"?"CRLF":&enc}',
      \     'separator': '', 'totalline': '%L', 
      \     'fileinfo': '%{&fenc==#"utf-8"?"":&fenc!=#""?&fenc:&enc} %{&ff==#"unix"?"":&ff==#"dos"?"CRLF":&enc} %{&ft!=#""?&ft:"plain"}:%L'
      \   },
      \   'component_visible_condition': {
      \     'modified': '&modified||!&modifiable', 'readonly': '&readonly', 'paste': '&paste', 'spell': '&spell'
      \   },
      \   'component_function': {
      \     'buffer_info': 'lightline#buffer#bufferinfo',
      \     'git_branch': 'fugitive#head',
      \   },
      \   'component_function_visible_condition': {},
      \   'component_expand': {
      \     'tabs': 'lightline#tabs',
      \     'buffer_current': 'lightline#buffer#buffercurrent',
      \     'buffer_before': 'lightline#buffer#bufferbefore',
      \     'buffer_after': 'lightline#buffer#bufferafter',
      \     'linter_warnings': 'lightline#ale#warnings',
      \     'linter_errors': 'lightline#ale#errors',
      \   },
      \   'component_type': {
      \     'tabs': 'tabsel', 'close': 'raw',
      \     'linter_warnings': 'warning', 'linter_errors': 'error',
      \     'buffer_current': 'tabsel', 'buffer_before': 'raw', 'buffer_after': 'raw',
      \   },
      \   'component_raw': {},
      \   'tab_component': {},
      \   'tab_component_function': {
      \     'filename': 'lightline#tab#filename', 'modified': 'lightline#tab#modified',
      \     'readonly': 'lightline#tab#readonly', 'tabnum': 'lightline#tab#tabnum',
      \   },
      \   'colorscheme': 'onedark',
      \   'mode_map': {
      \     'n': 'Normal', 'i': 'Insert', 'R': 'Replace', 'v': 'Visual', 'V': 'V-Line', "\<C-v>": 'V-Block',
      \     'c': 'Command', 's': 'Select', 'S': 'S-Line', "\<C-s>": 'S-Block', 't': 'Terminal',
      \   },
      \   'separator': { 'left': "", 'right': "" },
      \   'subseparator': { 'left': "", 'right': "" },
      \   'tabline_separator': {},
      \   'tabline_subseparator': {},
      \   'enable': { 'statusline': 1, 'tabline': 0 },
      \   '_mode_': {
      \     'n': 'normal', 'i': 'insert', 'R': 'replace', 'v': 'visual', 'V': 'visual', "\<C-v>": 'visual',
      \     'c': 'command', 's': 'select', 'S': 'select', "\<C-s>": 'select', 't': 'terminal'
      \   },
      \   'mode_fallback': { 'replace': 'insert', 'terminal': 'insert', 'select': 'visual' },
      \   'palette': {},
      \   'winwidth': winwidth(0),
      \ }
"}}}

" colorscheme settings
"{{{
if g:IsPlugged('onedark.vim')
    let g:onedark#colors = onedark#GetColors()
    let g:onedark#extend = { 'cterm': '234', 'gui': '#21252B' }
    augroup OverrideOnedark
        autocmd!
        autocmd ColorScheme * hi Tabline cterm=Bold gui=Bold
        autocmd ColorScheme * call onedark#set_highlight('EndOfBuffer', {
                    \ 'fg': g:onedark#colors.black })
        autocmd ColorScheme * call onedark#set_highlight('Structure', {
                    \ 'fg': g:onedark#colors.purple })
        autocmd ColorScheme * call onedark#set_highlight('StorageClass', {
                    \ 'fg': g:onedark#colors.purple })
        autocmd ColorScheme * call onedark#set_highlight('StatusLineNC', {
                    \ 'fg': g:onedark#colors.comment_grey,
                    \ 'bg': g:onedark#colors.cursor_grey })
        autocmd ColorScheme * call onedark#set_highlight('TablineSel', {
                    \ 'bg': g:onedark#extend })
        autocmd ColorScheme * call onedark#set_highlight('TablineFill', {
                    \ 'bg': g:onedark#extend })
        autocmd ColorScheme * call onedark#set_highlight('fishKeyword', {
                    \ 'fg': g:onedark#colors.purple })
    augroup END
end
if !has('nvim')
    augroup ModifyVimStyle
        autocmd!
        autocmd ColorScheme * hi Normal  ctermbg=none
        autocmd ColorScheme * hi NonText ctermbg=none
        autocmd ColorScheme * hi LineNr  ctermbg=none
        autocmd ColorScheme * hi Folded  ctermbg=none
        autocmd ColorScheme * hi EndOfBuffer ctermfg=235 ctermbg=none
        autocmd ColorScheme * hi StatusLineNC cterm=Italic gui=Italic
    augroup END
end
if g:IsPlugged('onedark.vim')
    color onedark
else
    set background=dark
endif
"}}}

" settings for some terminal emulator
" {{{
if !has('gui_running')
    if &term == 'xterm-256color'
        let &t_ti.="\e[0 q"
        let &t_SI.="\e[5 q"
        let &t_EI.="\e[1 q"
        let &t_te.="\e[0 q"
    elseif isdirectory('/data/data/com.termux')
        let &t_ti.="\e[1 q"
        let &t_SI.="\e[5 q"
        let &t_EI.="\e[1 q"
        let &t_te.="\e[0 q"
    elseif has('win32')
        " for ConEmu
        set term=xterm
        set t_Co=256
        let &t_AB="\e[48;5;%dm"
        let &t_AF="\e[38;5;%dm"
        inoremap <Char-0x07F> <BS>
        nnoremap <Char-0x07F> <BS>
    endif
endif
"}}}

