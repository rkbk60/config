
set encoding=utf8
scriptencoding utf-8
language C

" define variables and functions {{{
let s:here = fnamemodify(resolve(expand('<sfile>:p')), ':h')
let s:base = substitute(s:here, 'vim', 'files', 'g')
let s:app  = has('nvim') ? 'nvim' : 'vim'
let s:appbase = s:base.'/'.s:app

fun! IsPlugged(name)
    return exists('g:plugs') && has_key(g:plugs, a:name) && isdirectory(g:plugs[a:name].dir)
endfun

fun! GitInfo()
    if g:IsPlugged('vim-fugitive') && exists('*fugitive#head')
        let l:branch = fugitive#head()
        return (l:branch == '') ? '' : 'Git:'.l:branch.' '
    else
        return ''
    endif
endfun

fun! ImeInfo()
    return ''
endfun

fun! GuiRunning()
    return has('gui_running') || exists('g:oni_gui')
endfun

fun! s:systemCmdPath(cmd)
    return system('type '.a:cmd.' 2> /dev/null | sed "s/'.a:cmd.' is //g"')
endfun
"}}}

" install vim-plug {{{
let s:vimplug = s:base.'/vim/autoload/plug.vim'
let s:plugins = s:base.'/'.s:app.'/plugged'

if empty(glob(s:vimplug))
    " Install vim-plug
    let s:vimplug_url = 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    if has('unix')
        exec 'silent !curl -fLo '.s:vimplug.' --create-dirs '.s:vimplug_url
    else
        let s:vimplug_win = substitute(s:vimplug, '/', '\\', 'g')
        call mkdir(fnamemodify(s:vimplug_win, ':h'), 'p')
        let s:cmd = &shell
        set shell=powershell
        exec 'silent !(New-Object Net.WebClient).DownloadFile("'.s:vimplug_url
                    \.'", $ExcutionContext.SessionState.Path.GetUnresolvedProviderPathFromPath("'
                    \.s:vimplug_win
                    \.'"))'
        exec 'set shell='.s:cmd
    endif
endif
" }}}

" install plugins {{{
if filereadable(s:vimplug)
    exec 'source '.s:vimplug
    call plug#begin(s:plugins)
    let g:vimproc#download_windows_dll = 1
    Plug 'Shougo/vimproc.vim', { 'do': 'make' }
        \ | Plug 'thinca/vim-quickrun'
    Plug 'joshdick/onedark.vim'
    Plug 'sheerun/vim-polyglot'
    Plug 'ctrlpvim/ctrlp.vim'
    Plug 'mattn/ctrlp-filer'
    Plug 'mattn/ctrlp-register'
    Plug 'kana/vim-smartinput'
    Plug 'tpope/vim-endwise'
    Plug 'jiangmiao/auto-pairs'
    Plug 'junegunn/vim-easy-align'
    Plug 'kana/vim-operator-user'
    Plug 'rhysd/vim-operator-surround'
    Plug 'tyru/caw.vim'
    Plug 'airblade/vim-gitgutter'
    Plug 'tpope/vim-fugitive'
    Plug 'othree/eregex.vim'
    Plug 'Yggdroot/indentLine'
    Plug 'mattn/emmet-vim', { 'for': ['html', 'markdown', 'svg', 'xml'] }
    Plug 'ryanoasis/vim-devicons'
    Plug 'chrisbra/unicode.vim'
    Plug 'tyru/eskk.vim'
    Plug 'fuenor/im_control.vim'
    Plug 'simeji/winresizer'
    if has('nvim') && has('unix')
        let g:python_host_prog = s:systemCmdPath('python2')
        let g:python3_host_prog = s:systemCmdPath('python3')
        Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
        Plug 'itchyny/lightline.vim'
        Plug 'taohex/lightline-buffer'
        Plug 'w0rp/ale'
        Plug 'Chiel92/vim-autoformat'
        Plug 'maximbaz/lightline-ale'
        Plug 'zchee/deoplete-clang', { 'for': 'cpp' }
        Plug 'zchee/deoplete-go', { 'for': 'go' }
        Plug 'fatih/vim-go', { 'for': 'go' }
        Plug 'eagletmt/neco-ghc', { 'for': 'haskell' }
        Plug 'nbouscal/vim-stylish-haskell', { 'for': 'haskell' }
        Plug 'JuliaEditorSupport/deoplete-julia', { 'for': 'julia' }
        Plug 'baabelfish/nvim-nim', { 'for': 'nim' }
        Plug 'zchee/deoplete-jedi', { 'for': 'python' }
        Plug 'tyru/open-browser.vim', { 'for': ['markdown', 'adoc'] }
            \ | Plug 'kannokanno/previm', { 'for': ['markdown', 'adoc']}
        Plug 'kassio/neoterm'
        Plug 'vimlab/split-term.vim'
    else
        Plug 'rhysd/wandbox-vim'
    endif
    call plug#end()

    " install plugins automatically on first run
    if empty(glob(s:plugins . '/?*'))
        au VimEnter *
            \   let g:plug_window = 'enew'
            \ | PlugInstall --sync | bd
            \ | source $MYVIMRC
            \ | let g:plug_window = 'vertical topleft new'
    endif
endif
"}}}

" options {{{
set lazyredraw
set number
set relativenumber
set fenc=utf-8
set fileformats=unix,dos
set showcmd
set cursorline
set tabstop=4
set softtabstop=4
set expandtab
set breakindent
set shiftwidth=4
set hidden
set virtualedit=block
set whichwrap=b,s,h,l,<,>,[,],~
set backspace=indent,eol,start
set wrap
set display=lastline
set pumheight=10
set mouse=a
set wildmenu
set wildignorecase
set clipboard=unnamedplus
set history=100
set list
set listchars=tab:)\ ,trail:-,eol:\ ,extends:>,precedes:<,nbsp:-
set splitright
set splitbelow
set hlsearch
set foldmethod=marker " set-foldtext will be defined by FoldTextCustom.
set nf=""
set modeline
set laststatus=2
set showtabline=2
set iminsert=0
set imsearch=-1
set ambiwidth=double
set titlestring=%M%{has('nvim')?'nvim':(has('gui_running')?'gvim':'vim')}%{strlen(@%)?'\ \ :\ '.expand('%:p:~'):''}
set tabline=\ %M%{tabpagenr()}.%n%{strlen(expand('%:f'))?'\ '.expand('%:t'):''}%=%{ImeInfo()}%{GitInfo()}%{&ff=='unix'?'':'CRLF\ '}%{&fenc==#'utf-8'?'':'Enc:'.&fenc.'\ '}%{strlen(&ft)?&ft:'plain'}:%L\  
if has('nvim')
    set noshowmode
else
    if exists('g:debug') && g:debug == 1
        set statusline=\ %M%n.%v.%l\ \ %{synIDattr(synID(line('.'),col('.'),1),'name')}%=%{strlen(expand('%:f'))?expand('%:t'):'\ -\ '}\  
    else
        set statusline=\ %M%n.%v.%l%=%{strlen(expand('%:f'))?expand('%:t'):'\ -\ '}\  
    endif
endif

let s:tmpdir = s:base.'/'.s:app.'/tmp'
if empty(glob(s:tmpdir))
    call mkdir(s:tmpdir, "p")
    call mkdir(s:tmpdir.'/backup')
    call mkdir(s:tmpdir.'/swap')
    call mkdir(s:tmpdir.'/undo')
endif
set backup
set undofile
exec 'set backupdir='.s:tmpdir.'/backup'
exec 'set directory='.s:tmpdir.'/swap'
exec 'set undodir='.s:tmpdir.'/undo'
exec 'set viminfo+=n'.s:tmpdir.'/viminfo.txt'

if executable('fish')
    set shell=fish
endif
"}}}

" keymaps {{{
let g:mapleader="<Space>"
noremap j gj
noremap k gk
noremap gj j
noremap gk k
noremap <Up> gk
noremap <Down> gj
noremap <A-Up> <C-b>
noremap <A-Down> <C-f>
noremap <A-Left> 0
noremap <A-Right> $
noremap <C-Left> b
noremap <C-Right> w
nnoremap <C-Up> "zdd<Up>"zP
nnoremap <C-Down> "zdd"zp
vnoremap <C-Up> "zdd<Up>"zP
vnoremap <C-Down> "zdd"zp
vnoremap < <gv
vnoremap > >gv
noremap + <C-a>
noremap - <C-x>
inoremap <C-Backspace> <ESC>ciw
inoremap <C-Delete> <Space><ESC>ciw
inoremap <C-H> <ESC>ciw
inoremap <C-;> <Delete>
inoremap <C-+> <Space><ESC>ciw
nnoremap <Tab> <C-w>w
nnoremap <BackSpace> <C-w>W
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-d> <Del>
nnoremap <silent>BB :bn<CR>
noremap x "_x
noremap X "_X
noremap s "_s
noremap S "_S
tnoremap <S-Space> <Space>
"}}}

" settings NOT related to plugins {{{
let g:vim_indent_cont = &tabstop

" regard 'md' as 'markdown'
aug MdAsMarkdown
    au!
    au BufNewFile,BufRead *.{md,mdwn,mkd,mkdn,mark*} set ft=markdown
aug END

" apply vim-anyfold style foldtext method
fun! FoldTextCustom()
    let fs = v:foldstart
    while getline(fs) !~ '\w'
        let fs = nextnonblank(fs + 1)
    endwhile
    if fs > v:foldend
        let line = getline(v:foldstart)
    else
        let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
    endif
    let line = substitute(line, '\v\{{3}(\d){0,1}', '{...}', 'g')

    let w = winwidth(0) - &foldcolumn - &number * &numberwidth
    let foldSize = 1 + v:foldend - v:foldstart
    let foldSizeStr = " " . foldSize . " lines "
    let foldLevelStr = repeat("==", v:foldlevel)
    let lineCount = line("$")
    let expansionString = repeat(" ", w - strwidth(foldSizeStr.line.foldLevelStr))
    return line . expansionString . foldSizeStr . foldLevelStr
endfun
set foldtext=FoldTextCustom()
"}}}

" settings related to plugins {{{
let g:is_posix = 1

"   input methods setting {{{
let g:skk_dict_path = has('win32') ? $HOME."/skk/" : '/usr/share/skk/'
let g:skk_dict = g:skk_dict_path.'SKK-JISYO.L'
if g:IsPlugged('eskk.vim') && filereadable(g:skk_dict) " {{{
    set imdisable
    nnoremap <silent> <C-\><C-\> :<C-u>call eskk#toggle()<CR>
    let g:eskk#initial_mode = 'hira'
    let g:eskk#large_dictionary = {
        \ 'path': g:skk_dict,
        \ 'sorted': 0,
        \ 'encoding': 'euc-jp'
        \}
    let g:eskk#statusline_mode_strings = {'hira':'','kata':'','ascii':'','hankata':'','abbrev':''}
    let g:eskk#marker_henkan = '>'
    let g:eskk#marker_henkan_select = '>>'
    let g:use_color_cursor = 1 " cursol_color is defined at COLOR-SCHEME block
    let IM_CtrlMode = 0
    fun! ImeInfo()
        return printf(eskk#is_enabled() ? 'IME:eskk ' : '')
    endfun
    fun! EskkCustomMapping()
        let th = eskk#table#new('rom_to_hira*', 'rom_to_hira') " {{{
        call th.add_map('z!',   '●')
        call th.add_map('z1',   '○')
        call th.add_map('z"',   '▼')
        call th.add_map('z2',   '▽')
        call th.add_map('z#',   '▲')
        call th.add_map('z3',   '△')
        call th.add_map('z$',   '■')
        call th.add_map('z4',   '□')
        call th.add_map('z%',   '◆')
        call th.add_map('z5',   '◇')
        call th.add_map('z&',   '★')
        call th.add_map('z6',   '☆')
        call th.add_map("z'",   '♪')
        call th.add_map('z7',   '◎')
        call th.add_map('z(',   '【')
        call th.add_map('z8',   '〔')
        call th.add_map('z)',   '】')
        call th.add_map('z9',   '〕')
        call th.add_map('z0',   '∞')
        call th.add_map('z=',   '≒')
        call th.add_map('z-',   '〜')
        call th.add_map('z~',   '≠')
        call th.add_map('z^',   '※')
        call th.add_map('z|',   '〒')
        call th.add_map('z\\',  '￥')
        call th.add_map('z`',   '〆')
        call th.add_map('z@',   '〃')
        call th.add_map('z+',   '±')
        call th.add_map('z;',   '゛')
        call th.add_map('z*',   '×')
        call th.add_map('z,',   '゜')
        call th.add_map('z<',   '＜')
        call th.add_map('z>',   '＞')
        call th.add_map('z?',   '÷')
        call th.add_map('z/',   '・')
        call th.add_map('z_',   '―')
        call th.add_map('z ',   '　')
        call th.add_map('zL',   '⇒')
        call th.add_map('xca',  'ゕ')
        call th.add_map('xce',  'ゖ')
        call th.add_map('xva',  'ヷ')
        call th.add_map('xvi',  'ヸ')
        call th.add_map('xvu',  'ゔ')
        call th.add_map('xve',  'ヹ')
        call th.add_map('xvo',  'ヺ')
        call th.add_map('xnga', 'か゚')
        call th.add_map('xngi', 'き゚')
        call th.add_map('xngu', 'く゚')
        call th.add_map('xnge', 'け')
        call th.add_map('xngo', 'こ゚')
        call th.add_map('!',     '!')
        call th.add_map('?',     '?')
        call th.add_map('x!',   '！')
        call th.add_map('x?',   '？')
        call eskk#register_mode_table('hira', th)
        " }}}
        let tk = eskk#table#new('rom_to_kata*', 'rom_to_kata') " {{{
        call tk.add_map('z!',   '●')
        call tk.add_map('z1',   '○')
        call tk.add_map('z"',   '▼')
        call tk.add_map('z2',   '▽')
        call tk.add_map('z#',   '▲')
        call tk.add_map('z3',   '△')
        call tk.add_map('z$',   '■')
        call tk.add_map('z4',   '□')
        call tk.add_map('z%',   '◆')
        call tk.add_map('z5',   '◇')
        call tk.add_map('z&',   '★')
        call tk.add_map('z6',   '☆')
        call tk.add_map("z'",   '♪')
        call tk.add_map('z7',   '◎')
        call tk.add_map('z(',   '【')
        call tk.add_map('z8',   '〔')
        call tk.add_map('z)',   '】')
        call tk.add_map('z9',   '〕')
        call tk.add_map('z0',   '∞')
        call tk.add_map('z=',   '≒')
        call tk.add_map('z-',   '〜')
        call tk.add_map('z~',   '≠')
        call tk.add_map('z^',   '※')
        call tk.add_map('z|',   '〒')
        call tk.add_map('z\\',  '￥')
        call tk.add_map('z`',   '〆')
        call tk.add_map('z@',   '〃')
        call tk.add_map('z+',   '±')
        call tk.add_map('z;',   '゛')
        call tk.add_map('z*',   '×')
        call tk.add_map('z,',   '゜')
        call tk.add_map('z<',   '＜')
        call tk.add_map('z>',   '＞')
        call tk.add_map('z?',   '÷')
        call tk.add_map('z/',   '・')
        call tk.add_map('z_',   '―')
        call tk.add_map('z ',   '　')
        call tk.add_map('zL',   '⇒')
        call tk.add_map('xca',  'ヵ')
        call tk.add_map('xce',  'ヶ')
        call tk.add_map('xva',  'ヷ')
        call tk.add_map('xvi',  'ヸ')
        call tk.add_map('xvu',  'ヴ')
        call tk.add_map('xve',  'ヹ')
        call tk.add_map('xvo',  'ヺ')
        call tk.add_map('xnga', 'カ゚')
        call tk.add_map('xngi', 'キ゚')
        call tk.add_map('xngu', 'ク゚')
        call tk.add_map('xnge', 'ケ゚')
        call tk.add_map('xngo', 'コ゚')
        call tk.add_map('!',     '!')
        call tk.add_map('?',     '?')
        call tk.add_map('x!',   '！')
        call tk.add_map('x?',   '？')
        call eskk#register_mode_table('kata', tk)
        " }}}
    endfun
    aug EskkHooks
        au!
        au User eskk-initialize-pre call EskkCustomMapping()
        au User eskk-enable-post    set showtabline=2
        au User eskk-disable-post   set showtabline=2
    aug END
    " }}}
elseif g:IsPlugged('im_control.vim') " {{{
    if has('win32')
        let IM_CtrlMode = 4
        silent call IMState('FixMode')
        inoremap <silent> <C-j> <C-^><C-r>=IMState('FixMode')<CR>
    elseif has('unix')
        let g:jp_input = trim(system('ibus list-engine 2>&1 | grep -os "mozc-jp" --color=never'))
        if g:jp_input ==# 'mozc-jp'
            silent system('ibus engine "mozc-jp"')
            let IM_CtrlMode = 1
            inoremap <silent> <C-j> <C-r>=IMState('FixMode')<CR>
            fun! IMCtrl(cmd)
                if a:cmd ==# 'On'
                    let res = system('ibus engine "mozc-jp"')
                elseif a:cmd ==# 'Off'
                    let res = system('ibus engine "xkb:jp::jpn"')
                endif
                silent set showtabline=2
                return ''
            endfun
            fun! ImeInfo()
                let l:current_jp_input = trim(system('ibus engine 2>&1 | grep -os "mozc-jp" --color=never'))
                return printf('IME:mozc%s ', IMStatus('(Lock)'))
            endfun
        endif
    endif
    "}}}
endif
"   }}}

"   input helpers {{{
if g:IsPlugged('vim-smartinput-endwise')
    call smartinput_endwise#define_default_rules()
endif

if g:IsPlugged('vim-easy-align')
    vmap <CR> <Plug>(EasyAlign)
endif

if g:IsPlugged('vim-operator-surround')
    nmap <Space>y <Plug>(operator-surround-append)
    nmap <Space>d <Plug>(operator-surround-delete)
    nmap <Space>r <Plug>(operator-surround-replace)
endif

if g:IsPlugged('deoplete.vim')
    let g:deoplete#enable_at_startup = 1
    let g:deoplete#auto_complete_delay = 0
    let g:deoplete#auto_complete_start_length = 1
    let g:deoplete#max_list = 10000
    let g:deoplete#omni_patterns = {}
    set completeopt-=preview
endif

" for emmet.vim
let g:user_emmet_expandabbr_key        = '<C-e>e'
let g:user_emmet_expandword_key        = '<C-e>E'
let g:user_emmet_update_tag            = '<C-e>u'
let g:user_emmet_balancetaginward_key  = '<C-e>d'
let g:user_emmet_balancetagoutward_key = '<C-e>D'
let g:user_emmet_next_key              = '<C-e>n'
let g:user_emmet_prev_key              = '<C-e>N'
let g:user_emmet_imagesize_key         = '<C-e>i'
let g:user_emmet_togglecomment_key     = '<C-e>/'
let g:user_emmet_splitjointag_key      = '<C-e>j'
let g:user_emmet_removetag_key         = '<C-e>k'
let g:user_emmet_anchorizeurl_key      = '<C-e>a'
let g:user_emmet_anchorizesummary_key  = '<C-e>A'
let g:user_emmet_mergelines_key        = '<C-e>m'
let g:user_emmet_codepretty_key        = '<C-e>c'
"}}}

"   language support, appearance {{{
let g:polyglot_disabled = ['markdown']

if g:IsPlugged('nim.vim')
    fun! JumpToDef()
        if exists("*GotoDefinition_" . &filetype)
            call GotoDefinition_{&filetype}()
        endif
    endfun
    noremap <M-g> :call JumpToDef()<CR>
    inoremap <M-g> <Esc>:call JumpTodDef()<CR>wi
endif

" for indentLine
let g:indentLine_char = "|"
let g:indentLine_fileTypeExclude = ['help']
let g:indentLine_bufNameExeclude  = ['!.*', 'term:.*'] 
"}}}

"   utilities {{{
if g:IsPlugged('ctrlp.vim')
    let g:ctrlp_map = '<C-p><C-b>'
    nnoremap <C-p><C-f> :<C-u>CtrlPFiler<CR>
    nnoremap <C-p><C-m> :<C-u>CtrlPMRU<CR>
    nnoremap <C-p><C-q> :<C-u>CtrlPQuickfix<CR>
    nnoremap <C-p><C-u> :<C-u>CtrlPUndo<CR>
    nnoremap <C-p><C-y> :<C-u>CtrlPRegister<CR>
    let g:ctrlp_lazy_update = 1
    let g:ctrlp_types = ['buf', 'mru', 'quickfix', 'undo', 'fil', 'filer']
    let g:ctrlp_open_muliple_files = 'ij'
    let g:ctrlp_cache_dir = s:base.'/'.s:app.'/ctrlp_cache'
    let g:ctrlp_custom_ignore = {
                \ 'dir':  '\v[\/]\.(git|hg|svn)$',
                \ 'file': '\v\.(exe|so|dll|png|jpeg|jpg|pdf)$'
                \ }
    if executable('rg')
        set grepprg=rg\ --color=never
        let g:ctrlp_clear_cache_on_exit = 1
        let g:ctrlp_user_command = 'rg %s --files --color=never -g ""'
        let g:ctrlp_use_caching = 0
    elseif executable('ag')
        set grepprg=ag\ --nocolor\ --nogroup
        let g:ctrlp_clear_cache_on_exit = 1
        let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup -g ""'
    endif
endif

" for open-browser(previm)
let g:netrw_nogx = 1
let g:previm_enable_realtime = 1

" for split-term
let g:disable_key_mappings = 1

if g:IsPlugged('vim-quickrun')
    nnoremap <F9> :<C-u>QuickRun
    if g:IsPlugged('wandbox-vim')
        nnoremap <silent><C-F9> <C-u>:QuickRun --runner wandbox<CR>
    endif
endif

" for quickrun
let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config._ = {
      \ 'runner': 'vimproc',
      \ 'outputter': 'error',
      \ 'outputter/error/success': 'buffer',
      \ 'outputter/error/error': 'quickfix',
      \ 'outputter/buffer/sprit': 'vertical',
      \ 'outputter/buffer/close_on_empty': 1,
      \ }
"}}}

"   lightline setting {{{
let g:lightline = {
      \   'active': {
      \     'left': [ [ 'mode', 'paste' ], [ 'filename', 'linter_errors', 'linter_warnings', 'modified' ] ],
      \     'right': [ [ 'lineinfo' ] ]
      \   },
      \   'inactive': {
      \     'left': [ [ 'filename' ] ],
      \     'right': [ [ 'lineinfo' ] ]
      \   },
      \   'tabline': {
      \     'left': [[ 'buffer_before', 'buffer_current', 'buffer_after' ]],
      \     'right': [ [], [ 'git_branch', 'fileinfo' ] ]
      \   },
      \   'tab': {
      \     'active':   [ 'modified', 'tabnum', 'filename' ],
      \     'inactive': [ 'modified', 'tabnum', 'filename' ]
      \   },
      \   'component': {
      \     'mode': '%{lightline#mode()}',
      \     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',
      \     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',
      \     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc==#"utf-8"?"":&fenc!=#""?&fenc:&enc}',
      \     'filetype': '%{&ft!=#""?&ft:"plain"}', 'percent': '%3p%%', 'percentwin': '%P',
      \     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'winnr': '%{winnr()}',
      \     'fileformat': '%{&ff==#"unix"?"":&ff==#"dos"?"CRLF":&enc}',
      \     'separator': '', 'totalline': '%L', 
      \     'fileinfo': '%{&fenc==#"utf-8"?"":&fenc!=#""?&fenc:&enc} %{&ff==#"unix"?"":&ff==#"dos"?"CRLF":&enc} %{&ft!=#""?&ft:"plain"}:%L'
      \   },
      \   'component_visible_condition': {
      \     'modified': '&modified||!&modifiable', 'readonly': '&readonly', 'paste': '&paste', 'spell': '&spell'
      \   },
      \   'component_function': {
      \     'buffer_info': 'lightline#buffer#bufferinfo',
      \     'git_branch': 'fugitive#head',
      \   },
      \   'component_function_visible_condition': {},
      \   'component_expand': {
      \     'tabs': 'lightline#tabs',
      \     'buffer_current': 'lightline#buffer#buffercurrent',
      \     'buffer_before': 'lightline#buffer#bufferbefore',
      \     'buffer_after': 'lightline#buffer#bufferafter',
      \     'linter_warnings': 'lightline#ale#warnings',
      \     'linter_errors': 'lightline#ale#errors',
      \   },
      \   'component_type': {
      \     'tabs': 'tabsel', 'close': 'raw',
      \     'linter_warnings': 'warning', 'linter_errors': 'error',
      \     'buffer_current': 'tabsel', 'buffer_before': 'raw', 'buffer_after': 'raw',
      \   },
      \   'component_raw': {},
      \   'tab_component': {},
      \   'tab_component_function': {
      \     'filename': 'lightline#tab#filename', 'modified': 'lightline#tab#modified',
      \     'readonly': 'lightline#tab#readonly', 'tabnum': 'lightline#tab#tabnum',
      \   },
      \   'colorscheme': 'onedark',
      \   'mode_map': {
      \     'n': 'Normal', 'i': 'Insert', 'R': 'Replace', 'v': 'Visual', 'V': 'V-Line', "\<C-v>": 'V-Block',
      \     'c': 'Command', 's': 'Select', 'S': 'S-Line', "\<C-s>": 'S-Block', 't': 'Terminal',
      \   },
      \   'separator': { 'left': "", 'right': "" },
      \   'subseparator': { 'left': "", 'right': "" },
      \   'tabline_separator': {},
      \   'tabline_subseparator': {},
      \   'enable': { 'statusline': 1, 'tabline': 0 },
      \   '_mode_': {
      \     'n': 'normal', 'i': 'insert', 'R': 'replace', 'v': 'visual', 'V': 'visual', "\<C-v>": 'visual',
      \     'c': 'command', 's': 'select', 'S': 'select', "\<C-s>": 'select', 't': 'terminal'
      \   },
      \   'mode_fallback': { 'replace': 'insert', 'terminal': 'insert', 'select': 'visual' },
      \   'palette': {},
      \   'winwidth': winwidth(0),
      \ }
"}}}

"}}}

" colorscheme settings {{{
if g:IsPlugged('onedark.vim')
    let g:onedark#colors = onedark#GetColors()
    let g:onedark#extend = { 'cterm16': '0', 'cterm': '234', 'gui': '#21252B' }
    aug OverrideOnedark
        au!
        au ColorScheme * hi Tabline cterm=Bold gui=Bold
        au ColorScheme * call onedark#set_highlight('EndOfBuffer', {
                    \ 'fg': g:onedark#colors.black })
        au ColorScheme * call onedark#set_highlight('Structure', {
                    \ 'fg': g:onedark#colors.purple })
        au ColorScheme * call onedark#set_highlight('StorageClass', {
                    \ 'fg': g:onedark#colors.purple })
        au ColorScheme * call onedark#set_highlight('StatusLineNC', {
                    \ 'fg': g:onedark#colors.comment_grey,
                    \ 'bg': g:onedark#colors.cursor_grey })
        au ColorScheme * call onedark#set_highlight('TablineSel', {
                    \ 'bg': g:onedark#extend })
        au ColorScheme * call onedark#set_highlight('TablineFill', {
                    \ 'bg': g:onedark#extend })
        au ColorScheme * call onedark#set_highlight('Cursor', {
                    \ 'bg': g:onedark#colors.blue })
        au ColorScheme * call onedark#set_highlight('fishKeyword', {
                    \ 'fg': g:onedark#colors.purple })
    aug END

    if IsPlugged('eskk.vim')
        let g:eskk#cursor_color = {
            \ 'ascii':  [ g:onedark#colors.yellow['gui'], g:onedark#colors.yellow['gui'] ],
            \ 'hira':   [ g:onedark#colors.red['gui'],    g:onedark#colors.red['gui']    ],
            \ 'kata':   [ g:onedark#colors.green['gui'],  g:onedark#colors.green['gui']  ],
            \ 'abbrev': g:onedark#colors.purple['gui'],
            \ 'zenei':  g:onedark#colors.yellow['gui']
            \}
    endif
end
if !has('nvim')
    aug ModifyVimStyle
        au!
        au ColorScheme * hi Normal  ctermbg=none
        au ColorScheme * hi NonText ctermbg=none
        au ColorScheme * hi LineNr  ctermbg=none
        au ColorScheme * hi Folded  ctermbg=none
        au ColorScheme * hi EndOfBuffer ctermfg=235 ctermbg=none
        au ColorScheme * hi StatusLineNC cterm=Italic gui=Italic
    aug END
end
if g:IsPlugged('onedark.vim')
    color onedark
else
    set background=dark
endif
"}}}

" settings for some terminal emulators {{{
if !has('gui_running')
    if &term == 'xterm-256color'
        let &t_ti.="\e[0 q"
        let &t_SI.="\e[5 q"
        let &t_EI.="\e[1 q"
        let &t_te.="\e[0 q"
    elseif &term == 'linux'
        let &t_Co=16
    elseif isdirectory('/data/data/com.termux')
        let &t_ti.="\e[1 q"
        let &t_SI.="\e[5 q"
        let &t_EI.="\e[1 q"
        let &t_te.="\e[0 q"
    elseif has('win32')
        " for ConEmu
        set term=xterm
        set t_Co=256
        let &t_AB="\e[48;5;%dm"
        let &t_AF="\e[38;5;%dm"
        inoremap <Char-0x07F> <BS>
        nnoremap <Char-0x07F> <BS>
    endif
endif
"}}}
