
set encoding=utf8
scriptencoding utf-8
language C

" define variables and functions {{{1
let s:here = fnamemodify(resolve(expand('<sfile>:p')), ':h')
let s:base = substitute(s:here, 'vim', '.data', 'g')
let s:app  = has('nvim') ? 'nvim' : 'vim'

fun! IsPlugged(name)
    return exists('g:plugs') && has_key(g:plugs, a:name) && isdirectory(g:plugs[a:name].dir)
endfun
"}}}1

" install vim-plug {{{1
let s:vimplug = s:base.'/vim/autoload/plug.vim'
let s:plugins = s:base.'/'.s:app.'/plugged'

if empty(glob(s:vimplug))
    " Install vim-plug
    let s:vimplug_url = 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    if has('unix')
        exec 'silent !curl -fLo '.s:vimplug.' --create-dirs '.s:vimplug_url
    else
        let s:vimplug_win = substitute(s:vimplug, '/', '\\', 'g')
        call mkdir(fnamemodify(s:vimplug_win, ':h'), 'p')
        let s:cmd = &shell
        set shell=powershell
        exec 'silent !(New-Object Net.WebClient).DownloadFile("'.s:vimplug_url
            \.'", $ExcutionContext.SessionState.Path.GetUnresolvedProviderPathFromPath("'
            \.s:vimplug_win
            \.'"))'
        exec 'set shell='.s:cmd
    endif
endif
" }}}1

" install plugins {{{1
if filereadable(s:vimplug)
    exec 'source '.s:vimplug
    call plug#begin(s:plugins)
    let g:vimproc#download_windows_dll = 1
    Plug 'Shougo/vimproc.vim', { 'do': 'make' }
        \ | Plug 'thinca/vim-quickrun'
    Plug 'joshdick/onedark.vim'
    Plug 'sheerun/vim-polyglot'
    Plug 'kana/vim-smartinput'
    Plug 'tpope/vim-endwise'
    Plug 'jiangmiao/auto-pairs'
    Plug 'junegunn/vim-easy-align'
    Plug 'kana/vim-operator-user'
    Plug 'rhysd/vim-operator-surround'
    Plug 'tomtom/tcomment_vim'
    Plug 'osyo-manga/vim-over'
    Plug 'airblade/vim-gitgutter'
    Plug 'tpope/vim-fugitive'
    Plug 'Yggdroot/indentLine'
    Plug 'mattn/emmet-vim', { 'for': ['css', 'html', 'markdown', 'svg', 'xml'] }
    Plug 'tyru/eskk.vim'
    Plug 'fuenor/im_control.vim'
    Plug 'simeji/winresizer'
    if has('nvim') && has('unix')
        let g:python_host_prog  = "/usr/bin/python2"
        let g:python3_host_prog = "/usr/bin/python3"
        Plug 'Shougo/denite.nvim', { 'do': ':UpdateRemotePlugins' }
        Plug 'chemzqm/denite-extra'
        Plug 'Shougo/neoyank.vim'
        Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
        Plug 'itchyny/lightline.vim'
        Plug 'w0rp/ale'
        Plug 'Chiel92/vim-autoformat'
        Plug 'maximbaz/lightline-ale'
        Plug 'zchee/deoplete-clang',              { 'for': 'cpp' }
        Plug 'dag/vim-fish',                      { 'for': 'fish' }
        Plug 'ponko2/deoplete-fish',              { 'for': 'fish' }
        Plug 'fatih/vim-go',                      { 'for': 'go', 'do': ':GoInstallBinaries' }
        Plug 'zchee/deoplete-go',                 { 'for': 'go' }
        Plug 'eagletmt/neco-ghc',                 { 'for': 'haskell' }
        Plug 'nbouscal/vim-stylish-haskell',      { 'for': 'haskell' }
        Plug 'JuliaEditorSupport/deoplete-julia', { 'for': 'julia' }
        Plug 'baabelfish/nvim-nim',               { 'for': 'nim' }
        Plug 'zchee/deoplete-jedi',               { 'for': 'python' }
        Plug 'Shougo/neco-vim',                   { 'for': 'vim' }
        Plug 'Shougo/neco-syntax'
        Plug 'ujihisa/neco-look'
        Plug 'tyru/open-browser.vim', { 'for': ['markdown', 'adoc'], 'on': 'PrevimOpen' }
        Plug 'kannokanno/previm',     { 'for': ['markdown', 'adoc'], 'on': 'PrevimOpen' }
        Plug 'kassio/neoterm'
        Plug 'vimlab/split-term.vim'
    else
        Plug 'ctrlpvim/ctrlp.vim'
        Plug 'mattn/ctrlp-filer'
        Plug 'mattn/ctrlp-register'
        Plug 'rhysd/wandbox-vim'
    endif
    if !has('nvim')
        Plug 'thinca/vim-fontzoom'
    endif
    call plug#end()

    " install plugins automatically on first run
    if empty(glob(s:plugins . '/?*'))
        au VimEnter *
            \   let g:plug_window = 'enew'
            \ | PlugInstall --sync | bd
            \ | source $MYVIMRC
            \ | let g:plug_window = 'vertical topleft new'
    endif
endif
"}}}1

" options {{{1
set lazyredraw
set number
set relativenumber
set fenc=utf-8
set fileformats=unix,dos
set showcmd
set cursorline
set tabstop=4
set softtabstop=4
set expandtab
set breakindent
set shiftwidth=4
set hidden
set virtualedit=block
set whichwrap=b,s,h,l,<,>,[,],~
set backspace=indent,eol,start
set wrap
set display=lastline
set pumheight=10
set mouse=a
set wildmenu
set ignorecase
set smartcase
set clipboard=unnamedplus
set history=100
set list
set listchars=tab:)\ ,trail:-,eol:\ ,extends:>,precedes:<,nbsp:-
set splitright
set splitbelow
set hlsearch
set foldmethod=marker " set-foldtext will be defined by FoldTextCustom.
set nf=""
set autowrite
set nocompatible
set modeline
set laststatus=2
set showtabline=2
set iminsert=0
set imsearch=-1
set ambiwidth=double
set titlestring=%M%{has('nvim')?'nvim':(has('gui_running')?'gvim':'vim')}%{strlen(@%)?'\ \ :\ '.expand('%:p:~'):''}
set statusline=\ %M%n.%v.%l\ %{printf('')}\ %{exists('g:debug')&&g:debug==1?'color:'.synIDattr(synID(line('.'),col('.'),1),'name'):''}%=%{strlen(expand('%:f'))?expand('%:t'):'\ -\ '}\  
if has('nvim')
    set noshowmode
endif

let s:tmpdir = s:base.'/'.s:app.'/tmp'
if empty(glob(s:tmpdir))
    call mkdir(s:tmpdir, "p")
    call mkdir(s:tmpdir.'/backup')
    call mkdir(s:tmpdir.'/swap')
    call mkdir(s:tmpdir.'/undo')
endif
set backup
set undofile
exec 'set backupdir='.s:tmpdir.'/backup'
exec 'set directory='.s:tmpdir.'/swap'
exec 'set undodir='  .s:tmpdir.'/undo'
exec 'set viminfo+=n'.s:tmpdir.'/viminfo.txt'

if executable('fish')
    set shell=fish
    set shellpipe=|
endif
"}}}1

" keymaps {{{1
let g:mapleader="<Space>"
noremap j gj
noremap k gk
noremap gj j
noremap gk k
noremap <Up> gk
noremap <Down> gj
noremap <A-Up> <C-b>
noremap <A-Down> <C-f>
noremap <A-Left> 0
noremap <A-Right> $
noremap <C-Left> b
noremap <C-Right> w
nnoremap <C-Up> "zdd<Up>"zP
nnoremap <C-Down> "zdd"zp
vnoremap <C-Up> "zdd<Up>"zP
vnoremap <C-Down> "zdd"zp
vnoremap < <gv
vnoremap > >gv
noremap + <C-a>
noremap - <C-x>
inoremap <C-Backspace> <ESC>ciw
inoremap <C-Delete> <Space><ESC>ciw
inoremap <C-H> <ESC>ciw
inoremap <C-;> <Delete>
inoremap <C-+> <Space><ESC>ciw
nnoremap <Tab> <C-w>w
nnoremap <BackSpace> <C-w>W
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-d> <Del>
nnoremap <silent>BB :bn<CR>
noremap x "_x
noremap X "_X
noremap s "_s
noremap S "_S
tnoremap <S-Space> <Space>
tnoremap <C-@><C-w> <C-\><C-n><C-w>
"}}}1

" settings NOT related to plugins {{{1
let g:vim_indent_cont = &tabstop

" set custom tabline {{{2
fun! GitInfo()
    if IsPlugged('vim-fugitive') && exists('*fugitive#head')
        let l:branch = fugitive#head()
        return (l:branch == '') ? '' : 'Git:'.l:branch.' '
    else
        return ''
    endif
endfun

fun! ImeInfo()
    return ''
endfun

set tabline=\ %M%{tabpagenr()}.%n%{strlen(expand('%:f'))?'\ '.expand('%:t'):''}%=%{ImeInfo()}%{GitInfo()}%{&ff=='unix'?'':'CRLF\ '}%{&fenc==#'utf-8'?'':'Enc:'.&fenc.'\ '}%{strlen(&ft)?&ft:'plain'}:%L\  
"}}}2

" regard 'md' as 'markdown' {{{2
aug MdAsMarkdown
    au!
    au BufNewFile,BufRead *.{md,mdwn,mkd,mkdn,mark*} set ft=markdown
aug END
"}}}2

" apply vim-anyfold style foldtext method {{{2
fun! FoldTextCustom()
    let fs = v:foldstart
    while getline(fs) !~ '\w'
        let fs = nextnonblank(fs + 1)
    endwhile
    if fs > v:foldend
        let line = getline(v:foldstart)
    else
        let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
    endif
    let line = substitute(line, '\v\{{3}(\d{1,})', '{\1}', 'g')
    let line = substitute(line, '\v\{{3}', '{...}', 'g')

    let w = winwidth(0) - &foldcolumn - &number * &numberwidth
    let foldSize = 1 + v:foldend - v:foldstart
    let foldSizeStr = " " . foldSize . " lines "
    let foldLevelStr = repeat("==", v:foldlevel)
    let lineCount = line("$")
    let expansionString = repeat(" ", w - strwidth(foldSizeStr.line.foldLevelStr))
    return line . expansionString . foldSizeStr . foldLevelStr
endfun
set foldtext=FoldTextCustom()
"}}}2
"}}}1

" settings related to plugins {{{1
let g:is_posix = 1

" IMEs {{{2
let g:skk_dict_path = has('win32') ? $HOME."/skk/" : '/usr/share/skk/'
let g:skk_dict = g:skk_dict_path.'SKK-JISYO.L'
if IsPlugged('eskk.vim') && filereadable(g:skk_dict)
    " eskk settings {{{3
    set imdisable
    nnoremap <silent> <C-\><C-\> :<C-u>call EskkIntelijentToggle()<CR>
    let g:eskk#initial_mode = 'hira'
    let g:eskk#large_dictionary = {
        \ 'path': g:skk_dict,
        \ 'sorted': 0,
        \ 'encoding': 'euc-jp'
        \}
    let g:eskk#statusline_mode_strings = {'hira':'','kata':'','ascii':'','hankata':'','abbrev':''}
    let g:eskk#marker_henkan = '>'
    let g:eskk#marker_henkan_select = '>>'
    let g:use_color_cursor = 1 " cursol_color is defined at COLOR-SCHEME block
    let IM_CtrlMode = 0
    if has('unix')
        silent call system('ibus engine "xkb:jp::jpn" >/dev/null 2>&1')
    endif
    fun! ImeInfo()
        if !exists('g:next_ime_mode')
            return ''
        elseif g:next_ime_mode == 1
            return 'eskk '
        elseif g:next_ime_mode == 2
            return 'eskk(Lock) '
        endif
        return ''
    endfun
    fun! EskkCustomMapping()
        let th = eskk#table#new('rom_to_hira*', 'rom_to_hira') " {{{4
        call th.add_map(';',    'ー')
        call th.add_map(':',    'っ')
        call th.add_map('z!',   '●')
        call th.add_map('z1',   '○')
        call th.add_map('z"',   '▼')
        call th.add_map('z2',   '▽')
        call th.add_map('z#',   '▲')
        call th.add_map('z3',   '△')
        call th.add_map('z$',   '■')
        call th.add_map('z4',   '□')
        call th.add_map('z%',   '◆')
        call th.add_map('z5',   '◇')
        call th.add_map('z&',   '★')
        call th.add_map('z6',   '☆')
        call th.add_map("z'",   '♪')
        call th.add_map('z7',   '◎')
        call th.add_map('z(',   '【')
        call th.add_map('z8',   '〔')
        call th.add_map('z)',   '】')
        call th.add_map('z9',   '〕')
        call th.add_map('z0',   '∞')
        call th.add_map('z=',   '≒')
        call th.add_map('z-',   '〜')
        call th.add_map('z~',   '≠')
        call th.add_map('z^',   '※')
        call th.add_map('z|',   '〒')
        call th.add_map('z\\',  '￥')
        call th.add_map('z`',   '〆')
        call th.add_map('z@',   '〃')
        call th.add_map('z+',   '±')
        call th.add_map('z;',   '゛')
        call th.add_map('z*',   '×')
        call th.add_map('z,',   '゜')
        call th.add_map('z<',   '＜')
        call th.add_map('z>',   '＞')
        call th.add_map('z?',   '÷')
        call th.add_map('z/',   '・')
        call th.add_map('z_',   '―')
        call th.add_map('z ',   '　')
        call th.add_map('zL',   '⇒')
        call th.add_map('xca',  'ゕ')
        call th.add_map('xce',  'ゖ')
        call th.add_map('xva',  'ヷ')
        call th.add_map('xvi',  'ヸ')
        call th.add_map('xvu',  'ゔ')
        call th.add_map('xve',  'ヹ')
        call th.add_map('xvo',  'ヺ')
        call th.add_map('xnga', 'か゚')
        call th.add_map('xngi', 'き゚')
        call th.add_map('xngu', 'く゚')
        call th.add_map('xnge', 'け')
        call th.add_map('xngo', 'こ゚')
        call th.add_map('!',    '!')
        call th.add_map('?',    '?')
        call th.add_map('j!',   '！')
        call th.add_map('j?',   '？')
        call eskk#register_mode_table('hira', th)
        " }}}4
        let tk = eskk#table#new('rom_to_kata*', 'rom_to_kata') " {{{4
        call th.add_map(';',    'ー')
        call th.add_map(':',    'ッ')
        call tk.add_map('z!',   '●')
        call tk.add_map('z1',   '○')
        call tk.add_map('z"',   '▼')
        call tk.add_map('z2',   '▽')
        call tk.add_map('z#',   '▲')
        call tk.add_map('z3',   '△')
        call tk.add_map('z$',   '■')
        call tk.add_map('z4',   '□')
        call tk.add_map('z%',   '◆')
        call tk.add_map('z5',   '◇')
        call tk.add_map('z&',   '★')
        call tk.add_map('z6',   '☆')
        call tk.add_map("z'",   '♪')
        call tk.add_map('z7',   '◎')
        call tk.add_map('z(',   '【')
        call tk.add_map('z8',   '〔')
        call tk.add_map('z)',   '】')
        call tk.add_map('z9',   '〕')
        call tk.add_map('z0',   '∞')
        call tk.add_map('z=',   '≒')
        call tk.add_map('z-',   '〜')
        call tk.add_map('z~',   '≠')
        call tk.add_map('z^',   '※')
        call tk.add_map('z|',   '〒')
        call tk.add_map('z\\',  '￥')
        call tk.add_map('z`',   '〆')
        call tk.add_map('z@',   '〃')
        call tk.add_map('z+',   '±')
        call tk.add_map('z;',   '゛')
        call tk.add_map('z*',   '×')
        call tk.add_map('z,',   '゜')
        call tk.add_map('z<',   '＜')
        call tk.add_map('z>',   '＞')
        call tk.add_map('z?',   '÷')
        call tk.add_map('z/',   '・')
        call tk.add_map('z_',   '―')
        call tk.add_map('z ',   '　')
        call tk.add_map('zL',   '⇒')
        call tk.add_map('xca',  'ヵ')
        call tk.add_map('xce',  'ヶ')
        call tk.add_map('xva',  'ヷ')
        call tk.add_map('xvi',  'ヸ')
        call tk.add_map('xvu',  'ヴ')
        call tk.add_map('xve',  'ヹ')
        call tk.add_map('xvo',  'ヺ')
        call tk.add_map('xnga', 'カ゚')
        call tk.add_map('xngi', 'キ゚')
        call tk.add_map('xngu', 'ク゚')
        call tk.add_map('xnge', 'ケ゚')
        call tk.add_map('xngo', 'コ゚')
        call tk.add_map('!',    '!')
        call tk.add_map('?',    '?')
        call tk.add_map('j!',   '！')
        call tk.add_map('j?',   '？')
        call eskk#register_mode_table('kata', tk)
        " }}}4
    endfun
    fun! EskkIntelijentToggle()
        let g:next_ime_mode = exists('g:next_ime_mode') ? (g:next_ime_mode + 1) % 3 : 1
        if g:next_ime_mode == 0
            call eskk#disable()
            set showtabline=2
        else
            call eskk#enable()
            set showtabline=2
        endif
    endfun
    fun! FixEskkStatus()
        if exists('g:next_ime_mode') && g:next_ime_mode == 2
            call eskk#enable()
        else
            let g:next_ime_mode = eskk#is_enabled() ? 1 : 0
        endif
        set showtabline=2
    endfun
    aug EskkHooks
        au!
        au User eskk-initialize-pre call EskkCustomMapping()
        au User eskk-disable-post   call FixEskkStatus()
    aug END
    " }}}3
elseif IsPlugged('im_control.vim')
    " im_control settings {{{3
    if has('win32')
        let IM_CtrlMode = 4
        silent call IMState('FixMode')
        inoremap <silent> <C-j> <C-^><C-r>=IMState('FixMode')<CR>
    elseif has('unix')
        let s:has_mozc = system('ibus list-engine 2>&1 | grep -c "mozc-jp"')
        if s:has_mozc ==# '1'
            silent system('ibus engine "mozc-jp"')
            let IM_CtrlMode = 1
            inoremap <silent> <C-j> <C-r>=IMState('FixMode')<CR>
            fun! IMCtrl(cmd)
                if a:cmd ==# 'On'
                    let res = system('ibus engine "mozc-jp"')
                elseif a:cmd ==# 'Off'
                    let res = system('ibus engine "xkb:jp::jpn"')
                endif
                silent set showtabline=2
                return ''
            endfun
            fun! ImeInfo()
                return printf('mozc%s ', IMStatus('(Lock)'))
            endfun
        endif
    endif
    "}}}3
endif
"}}}2

" input helpers {{{2
if IsPlugged('vim-smartinput-endwise')
    call smartinput_endwise#define_default_rules()
endif

if IsPlugged('vim-easy-align')
    vmap <CR> <Plug>(EasyAlign)
endif

if IsPlugged('vim-operator-surround')
    nmap ey <Plug>(operator-surround-append)
    nmap ed <Plug>(operator-surround-delete)
    nmap er <Plug>(operator-surround-replace)
endif

if IsPlugged('deoplete.vim')
    call deoplete#enable()
    let g:deoplete#auto_complete_delay = 0
    let g:deoplete#auto_complete_start_length = 1
    let g:deoplete#max_list = 10000
    let g:deoplete#omni_patterns = {}
    set completeopt-=preview
    if IsPlugged('neco-vim')
        let g:necovim#complete_functions.Ref = 'ref#complete'
    endif
    if IsPlugged('deoplete-jedi')
        let g:deoplete#sources#jedi#python_path = g:python3_host_prog
    endif
endif

" for emmet.vim
let g:user_emmet_expandabbr_key        = '<C-e>e'
let g:user_emmet_expandword_key        = '<C-e>E'
let g:user_emmet_update_tag            = '<C-e>u'
let g:user_emmet_balancetaginward_key  = '<C-e>d'
let g:user_emmet_balancetagoutward_key = '<C-e>D'
let g:user_emmet_next_key              = '<C-e>n'
let g:user_emmet_prev_key              = '<C-e>N'
let g:user_emmet_imagesize_key         = '<C-e>i'
let g:user_emmet_togglecomment_key     = '<C-e>/'
let g:user_emmet_splitjointag_key      = '<C-e>j'
let g:user_emmet_removetag_key         = '<C-e>k'
let g:user_emmet_anchorizeurl_key      = '<C-e>a'
let g:user_emmet_anchorizesummary_key  = '<C-e>A'
let g:user_emmet_mergelines_key        = '<C-e>m'
let g:user_emmet_codepretty_key        = '<C-e>c'
"}}}2

" language support, appearance {{{2
" for tcomment_vim
let g:tcomment_mapleader1 = '<C-/>'
let g:tcomment_mapleader2 = '<C-/>'

let g:polyglot_disabled = ['markdown']

if IsPlugged('nim.vim')
    fun! JumpToDef()
        if exists("*GotoDefinition_" . &filetype)
            call GotoDefinition_{&filetype}()
        endif
    endfun
    noremap <M-g> :call JumpToDef()<CR>
    inoremap <M-g> <Esc>:call JumpTodDef()<CR>wi
endif

" for indentLine
let g:indentLine_char = '|'
let g:indentLine_fileTypeExclude = ['help']
let g:indentLine_bufNameExeclude  = ['!.*', 'term:.*']
"}}}2

" utilities {{{2
" for open-browser and previm
let g:netrw_nogx = 1
let g:previm_enable_realtime = 1

" for split-term
let g:disable_key_mappings = 1

if IsPlugged('vim-quickrun')
    nnoremap <F9> :<C-u>QuickRun
    if IsPlugged('wandbox-vim')
        nnoremap <silent><C-F9> <C-u>:QuickRun --runner wandbox<CR>
    endif
endif

" for quickrun
let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config._ = {
      \ 'runner': 'vimproc',
      \ 'outputter': 'error',
      \ 'outputter/error/success': 'buffer',
      \ 'outputter/error/error': 'quickfix',
      \ 'outputter/buffer/sprit': 'vertical',
      \ 'outputter/buffer/close_on_empty': 1,
      \ }
"}}}2

" launchers {{{2
if IsPlugged('denite.nvim')
    " denite settings {{{3
    " - Define keymaps to run denite command {{{4
    nnoremap <silent> <C-p>b  :<C-u>Denite buffer<CR>
    nnoremap <silent> <C-p>B  :<C-u>Denite buffer -buffer-name=file<CR>
    nnoremap <silent> <C-p>f  :<C-u>Denite file/rec<CR>
    nnoremap <silent> <C-p>g  :<C-u>Denite grep<CR>
    nnoremap <silent> <C-p>h  :<C-u>Denite history<CR>
    nnoremap <silent> <C-p>m  :<C-u>Denite file/old<CR>
    nnoremap <silent> <C-p>p  :<C-u>Denite project<CR>
    nnoremap <silent> <C-p>q  :<C-u>Denite quickfix<CR>
    nnoremap <silent> <C-p>ss :<C-u>Denite line<CR>
    nnoremap <silent> <C-p>sw :<C-u>DeniteWithCursorWord line<CR>
    nnoremap <silent> <C-p>y  :<C-u>Denite neoyank<CR>
    "}}}4

    " - Change mappings on denite {{{4
    call denite#custom#map('insert', '<C-j>', '<denite:move_to_next_line>', 'noremap')
    call denite#custom#map('insert', '<C-k>', '<denite:move_to_previous_line>', 'noremap')
    call denite#custom#map('insert', '<C-a>', '<Home>')
    call denite#custom#map('insert', '<C-e>', '<End>')
    call denite#custom#map('insert', '<C-f>', '<Right>')
    call denite#custom#map('insert', '<C-b>', '<Left>')
    "}}}4

    " - Change search options {{{4
    " Change matchers
    call denite#custom#source(
        \ 'file_mru', 'matchers', ['matcher/fuzzy', 'matcher/project_files'])
    call denite#custom#source(
        \ 'file/rec', 'matchers', ['matcher/cpsm'])

    " Change sorters.
    call denite#custom#source(
        \ 'file/rec', 'sorters', ['sorter/sublime'])
    "}}}4

    " - Add custom menus {{{4
    let s:menus = {}
    let s:menus.fish = {
        \ 'description': 'Edit your import fish configuration'
        \ }
    let s:menus.fish.file_candidates = [
        \ ['config', '~/.config/fish/config.fish']
        \ ]
    call denite#custom#var('menu', 'menus', s:menus)
    "}}}4

    " - Add alt-grep commands {{{4
    if executable('rg')
        call denite#custom#var('file/rec', 'command',
            \ ['rg', '--files', '--glob', '!.git'])
        call denite#custom#var('grep', 'command', ['rg'])
        call denite#custom#var('grep', 'default_opts',
            \ ['--vimgrep', '--no-heading'])
        call denite#custom#var('grep', 'recursive_opts', [])
        call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
        call denite#custom#var('grep', 'separator', ['--'])
        call denite#custom#var('grep', 'final_opts', [])
    elseif executable('pt')
        call denite#custom#var('file/rec', 'command',
            \ ['pt', '--follow', '--nocolor', '--nogroup',
            \  (has('win32') ? '-g:' : '-g='), ''])
        call denite#custom#var('grep', 'command', ['pt'])
        call denite#custom#var('grep', 'default_opts',
            \ ['--nogroup', '--nocolor', '--smart-case'])
        call denite#custom#var('grep', 'recursive_opts', [])
        call denite#custom#var('grep', 'pattern_opt', [])
        call denite#custom#var('grep', 'separator', ['--'])
        call denite#custom#var('grep', 'final_opts', [])
    elseif executable('ag')
        call denite#custom#var('file/rec', 'command',
            \ ['ag', '--follow', '--nocolor', '--nogroup', '-g', ''])
        call denite#custom#var('grep', 'command', ['ag'])
        call denite#custom#var('grep', 'default_opts',
            \ ['-i', '--vimgrep'])
        call denite#custom#var('grep', 'recursive_opts', [])
        call denite#custom#var('grep', 'pattern_opt', [])
        call denite#custom#var('grep', 'separator', ['--'])
        call denite#custom#var('grep', 'final_opts', [])
    endif

    if executable('ack')
        call denite#custom#var('grep', 'command', ['ack'])
        call denite#custom#var('grep', 'default_opts',
            \ ['--ackrc', $HOME.'/.ackrc', '-H',
            \  '--nopager', '--nocolor', '--nogroup', '--column'])
        call denite#custom#var('grep', 'recursive_opts', [])
        call denite#custom#var('grep', 'pattern_opt', ['--match'])
        call denite#custom#var('grep', 'separator', ['--'])
        call denite#custom#var('grep', 'final_opts', [])
    endif
    "}}}4

    " - Define alias {{{4
    call denite#custom#alias('source', 'file/rec/git', 'file/rec')
    call denite#custom#var('file/rec/git', 'command',
        \ ['git', 'ls-files', '-co', '--exclude-standard'])

    call denite#custom#alias('source', 'file/rec/py', 'file/rec')
    call denite#custom#var('file/rec/py', 'command',['scantree.py'])
    "}}}4

    " - Change appearance {{{4
    hi link DeniteMatchedChar Search
    hi link DeniteSearch Search
    call denite#custom#option('default', {
        \ 'auto_resize': v:true,
        \ 'highlight_matched_char': 'DeniteMatchedChar',
        \ 'highlight_mode_insert': 'DeniteSearch',
        \ 'prompt': '>',
        \ 'smartcase': v:true,
        \ 'winheight': '10'
        \})
    if IsPlugged('lightline.vim')
        call denite#custom#option('default', 'statusline', v:false)
    endif
    "}}}4

    " - Change ignore_globs {{{4
    call denite#custom#filter('matcher/ignore_globs', 'ignore_globs',
        \ [ '.git/', '.ropeproject/', '__pycache__/',
        \   'venv/', 'images/', '*.min.*', 'img/', 'fonts/'])
    "}}}4
    "}}}4
    "}}}3
elseif IsPlugged('ctrlp.vim')
    " ctrlp settings {{{3
    let g:ctrlp_map = '<Nop>'
    nnoremap <C-p>b :<C-u>CtrlPBuffer<CR>
    nnoremap <C-p>f :<C-u>CtrlPFiler<CR>
    nnoremap <C-p>m :<C-u>CtrlPMRU<CR>
    nnoremap <C-p>q :<C-u>CtrlPQuickfix<CR>
    nnoremap <C-p>u :<C-u>CtrlPUndo<CR>
    nnoremap <C-p>y :<C-u>CtrlPRegister<CR>
    let g:ctrlp_lazy_update = 100
    let g:ctrlp_types = ['buf', 'mru', 'fil', 'quickfix', 'undo', 'register']
    let g:ctrlp_open_muliple_files = 'ij'
    let g:ctrlp_cache_dir = s:base.'/'.s:app.'/ctrlp_cache'
    let g:ctrlp_custom_ignore = {
                \ 'dir':  '\v[\/]\.(git|hg|svn)$',
                \ 'file': '\v\.(exe|so|dll|png|jpeg|jpg|pdf)$'
                \ }
    if executable('rg')
        set grepprg=rg\ --color=never
        let g:ctrlp_clear_cache_on_exit = 1
        let g:ctrlp_user_command = 'rg %s --files --color=never -g ""'
        let g:ctrlp_use_caching = 0
    elseif executable('ag')
        set grepprg=ag\ --nocolor\ --nogroup
        let g:ctrlp_clear_cache_on_exit = 1
        let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup -g ""'
    endif
    "}}}3
endif
"}}}2

" lightline {{{2
fun! CustomLightlineMode()
    if &ft == 'denite'
        let l:raw = substitute(denite#get_status_mode(), '\v[- ]', "", 'g')
        call lightline#link(tolower(l:raw[0]))
        return 'Denite'
    else
        return lightline#mode()
    endif
endfun
let g:lightline = {
      \   'active': {
      \     'left': [ [ 'mode', 'paste' ], [ 'filename', 'linter_errors', 'linter_warnings', 'modified' ] ],
      \     'right': [ [ 'lineinfo' ] ]
      \   },
      \   'inactive': {
      \     'left': [ [ 'fnamewithbufnum' ] ],
      \     'right': [ [ 'lineinfo' ] ]
      \   },
      \   'tabline': {
      \     'left': [[ 'buffer_before', 'buffer_current', 'buffer_after' ]],
      \     'right': [ [], [ 'git_branch', 'fileinfo' ] ]
      \   },
      \   'tab': {
      \     'active':   [ 'modified', 'tabnum', 'filename' ],
      \     'inactive': [ 'modified', 'tabnum', 'filename' ]
      \   },
      \   'component': {
      \     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',
      \     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',
      \     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc==#"utf-8"?"":&fenc!=#""?&fenc:&enc}',
      \     'filetype': '%{&ft!=#""?&ft:"plain"}', 'percent': '%3p%%', 'percentwin': '%P',
      \     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'winnr': '%{winnr()}',
      \     'fileformat': '%{&ff==#"unix"?"":&ff==#"dos"?"CRLF":&enc}',
      \     'separator': '', 'totalline': '%L', 
      \     'fileinfo': '%{&fenc==#"utf-8"?"":&fenc!=#""?&fenc:&enc} %{&ff==#"unix"?"":&ff==#"dos"?"CRLF":&enc} %{&ft!=#""?&ft:"plain"}:%L',
      \     'fnamewithbufnum': '%n %t'
      \   },
      \   'component_visible_condition': {
      \     'modified': '&modified||!&modifiable', 'readonly': '&readonly', 'paste': '&paste', 'spell': '&spell'
      \   },
      \   'component_function': {
      \     'buffer_info': 'lightline#buffer#bufferinfo',
      \     'git_branch': 'fugitive#head',
      \     'mode': 'CustomLightlineMode'
      \   },
      \   'component_expand': {
      \     'tabs': 'lightline#tabs',
      \     'buffer_current': 'lightline#buffer#buffercurrent',
      \     'buffer_before': 'lightline#buffer#bufferbefore',
      \     'buffer_after': 'lightline#buffer#bufferafter',
      \     'linter_warnings': 'lightline#ale#warnings',
      \     'linter_errors': 'lightline#ale#errors',
      \   },
      \   'component_type': {
      \     'tabs': 'tabsel', 'close': 'raw',
      \     'linter_warnings': 'warning', 'linter_errors': 'error',
      \     'buffer_current': 'tabsel', 'buffer_before': 'raw', 'buffer_after': 'raw',
      \   },
      \   'tab_component_function': {
      \     'filename': 'lightline#tab#filename', 'modified': 'lightline#tab#modified',
      \     'readonly': 'lightline#tab#readonly', 'tabnum': 'lightline#tab#tabnum',
      \   },
      \   'colorscheme': 'default',
      \   'mode_map': {
      \     'n': 'Normal', 'i': 'Insert', 'R': 'Replace', 'v': 'Visual', 'V': 'V-Line', "\<C-v>": 'V-Block',
      \     'c': 'Command', 's': 'Select', 'S': 'S-Line', "\<C-s>": 'S-Block', 't': 'Terminal',
      \   },
      \   'enable': { 'statusline': 1, 'tabline': 0 },
      \   '_mode_': {
      \     'n': 'normal', 'i': 'insert', 'R': 'replace', 'v': 'visual', 'V': 'visual', "\<C-v>": 'visual',
      \     'c': 'command', 's': 'select', 'S': 'select', "\<C-s>": 'select', 't': 'terminal'
      \   },
      \   'mode_fallback': { 'replace': 'insert', 'terminal': 'insert', 'select': 'visual' },
      \   'winwidth': winwidth(0),
      \}
"}}}2

"}}}1

" colorscheme settings {{{1
if !has('nvim')
    aug ModifyVimStyle
        au!
        au ColorScheme * hi Normal  ctermbg=none
        au ColorScheme * hi NonText ctermbg=none
        au ColorScheme * hi LineNr  ctermbg=none
        au ColorScheme * hi Folded  ctermbg=none
        au ColorScheme * hi EndOfBuffer ctermfg=235 ctermbg=none
        au ColorScheme * hi StatusLineNC cterm=Italic gui=Italic
    aug END
end
if IsPlugged('onedark.vim')
    let g:lightline.colorscheme = 'onedark'
    let g:onedark#colors = onedark#GetColors()
    let g:onedark#extend = {
        \ 'blue': { 'cterm16': '4', 'cterm': '17',  'gui': '#314383' },
        \ 'gray': { 'cterm16': '0', 'cterm': '234', 'gui': '#21252B' }
        \}
    aug OverrideOnedark
        au!
        au ColorScheme * call onedark#set_highlight('EndOfBuffer', {
            \ 'fg': g:onedark#colors.black })
        au ColorScheme * call onedark#set_highlight('Structure', {
            \ 'fg': g:onedark#colors.purple })
        au ColorScheme * call onedark#set_highlight('StorageClass', {
            \ 'fg': g:onedark#colors.purple })
        au ColorScheme * call onedark#set_highlight('StatusLineNC', {
            \ 'fg': g:onedark#colors.comment_grey,
            \ 'bg': g:onedark#colors.cursor_grey })
        au ColorScheme * call onedark#set_highlight('TablineSel', {
            \ 'bg': g:onedark#extend.gray })
        au ColorScheme * call onedark#set_highlight('TablineFill', {
            \ 'bg': g:onedark#extend.gray })
        au ColorScheme * call onedark#set_highlight('Cursor', {
            \ 'bg': g:onedark#colors.blue })
        au ColorScheme * call onedark#set_highlight('fishKeyword', {
            \ 'fg': g:onedark#colors.purple })
        au ColorScheme * call onedark#set_highlight('shQuote', {
            \ 'fg': g:onedark#colors.green })
        au ColorScheme * call onedark#set_highlight('DeniteMatchedChar', {
            \ 'fg': g:onedark#colors.red })
        au ColorScheme * call onedark#set_highlight('DeniteSearch', {
            \ 'fg': g:onedark#colors.yellow,
            \ 'bg': g:onedark#colors.cursor_grey })
    aug END

    " for indentLine
    let g:indentLine_color_term = g:onedark#colors.comment_grey['cterm']
    let g:indentLine_color_gui  = g:onedark#colors.comment_grey['gui']
    let g:indentLine_color_tty_light = g:onedark#colors.comment_grey['cterm16']
    let g:indentLine_color_tty_dark  = g:onedark#colors.comment_grey['cterm16']

    if IsPlugged('eskk.vim')
        let g:eskk#cursor_color = {
            \ 'ascii':  [ g:onedark#colors.yellow['gui'], g:onedark#colors.yellow['gui'] ],
            \ 'hira':   [ g:onedark#colors.red['gui'],    g:onedark#colors.red['gui']    ],
            \ 'kata':   [ g:onedark#colors.green['gui'],  g:onedark#colors.green['gui']  ],
            \ 'abbrev': g:onedark#colors.purple['gui'],
            \ 'zenei':  g:onedark#colors.yellow['gui']
            \}
    endif

    color onedark
else
    set background=dark
endif
"}}}1

" settings for some terminal emulators {{{1
if !has('gui_running')
    if &term == 'xterm-256color'
        let &t_ti.="\e[0 q"
        let &t_SI.="\e[5 q"
        let &t_EI.="\e[1 q"
        let &t_te.="\e[0 q"
    elseif &term == 'linux'
        let &t_Co=16
    elseif isdirectory('/data/data/com.termux')
        let &t_ti.="\e[1 q"
        let &t_SI.="\e[5 q"
        let &t_EI.="\e[1 q"
        let &t_te.="\e[0 q"
    elseif has('win32')
        " for ConEmu
        set term=xterm
        set t_Co=256
        let &t_AB="\e[48;5;%dm"
        let &t_AF="\e[38;5;%dm"
        inoremap <Char-0x07F> <BS>
        nnoremap <Char-0x07F> <BS>
    endif
endif
"}}}1
